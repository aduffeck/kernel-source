From: Michal Kubecek <mkubecek@suse.cz>
Date: Tue, 1 Dec 2015 15:44:03 +0100
Subject: kabi: protect struct unix_sock layout after epoll fix
Patch-mainline: Never, kabi workaround
References: CVE-2013-7446 bsc#917648 bsc#955654

The fix for bsc#917648 adds a wait_queue_t member into struct unix_sock.
We can't do that but fortunately there are unused members to store a
pointer to a separately allocated structure. We need a wrapper structure
with a pointer back to the socket as we can no longer use container_of()
to get it from the wait_queue_t. Destination and source IPv4 addresses
are used to store the pointer as these are not used for AF_UNIX sockets.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/af_unix.h | 33 ++++++++++++++++++++++++++++++++-
 net/unix/af_unix.c    | 32 ++++++++++++++++++++------------
 2 files changed, 52 insertions(+), 13 deletions(-)

diff --git a/include/net/af_unix.h b/include/net/af_unix.h
index cb4a7284e656..895af09f4a65 100644
--- a/include/net/af_unix.h
+++ b/include/net/af_unix.h
@@ -63,12 +63,43 @@ struct unix_sock {
 #define UNIX_GC_CANDIDATE	0
 #define UNIX_GC_MAYBE_CYCLE	1
 	struct socket_wq	peer_wq;
-	wait_queue_t		peer_wake;
 };
 #define unix_sk(__sk) ((struct unix_sock *)__sk)
 
 #define peer_wait peer_wq.wait
 
+struct unix_peer_wake {
+	wait_queue_t		wq;
+	struct unix_sock	*sk;
+};
+
+static inline wait_queue_t *get_peer_wake(struct unix_sock *usk)
+{
+	struct unix_peer_wake *pw;
+
+	pw = *((struct unix_peer_wake **)&usk->sk.__sk_common.skc_daddr);
+	return &pw->wq;
+}
+
+static inline void set_peer_wake(struct unix_sock *usk,
+				 struct unix_peer_wake *pw)
+{
+	pw->sk = usk;
+	*((struct unix_peer_wake **)&usk->sk.__sk_common.skc_daddr) = pw;
+}
+
+static inline struct unix_sock *get_peer_wake_sk(wait_queue_t *q)
+{
+	struct unix_peer_wake *pw = container_of(q, struct unix_peer_wake, wq);
+
+	return pw->sk;
+}
+
+static inline void unix_release_peer_wake(struct unix_sock *usk)
+{
+	kfree(*((struct unix_peer_wake **)&usk->sk.__sk_common.skc_daddr));
+}
+
 long unix_inq_len(struct sock *sk);
 long unix_outq_len(struct sock *sk);
 
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index c5864bb0b112..d6f928bdeb3f 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -347,11 +347,11 @@ static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,
 	struct unix_sock *u;
 	wait_queue_head_t *u_sleep;
 
-	u = container_of(q, struct unix_sock, peer_wake);
+	u = get_peer_wake_sk(q);
 
-	__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,
+	__remove_wait_queue(&unix_sk(get_peer_wake(u)->private)->peer_wait,
 			    q);
-	u->peer_wake.private = NULL;
+	get_peer_wake(u)->private = NULL;
 
 	/* relaying can only happen while the wq still exists */
 	u_sleep = sk_sleep(&u->sk);
@@ -371,9 +371,9 @@ static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)
 	rc = 0;
 	spin_lock(&u_other->peer_wait.lock);
 
-	if (!u->peer_wake.private) {
-		u->peer_wake.private = other;
-		__add_wait_queue(&u_other->peer_wait, &u->peer_wake);
+	if (!get_peer_wake(u)->private) {
+		get_peer_wake(u)->private = other;
+		__add_wait_queue(&u_other->peer_wait, get_peer_wake(u));
 
 		rc = 1;
 	}
@@ -391,9 +391,9 @@ static void unix_dgram_peer_wake_disconnect(struct sock *sk,
 	u_other = unix_sk(other);
 	spin_lock(&u_other->peer_wait.lock);
 
-	if (u->peer_wake.private == other) {
-		__remove_wait_queue(&u_other->peer_wait, &u->peer_wake);
-		u->peer_wake.private = NULL;
+	if (get_peer_wake(u)->private == other) {
+		__remove_wait_queue(&u_other->peer_wait, get_peer_wake(u));
+		get_peer_wake(u)->private = NULL;
 	}
 
 	spin_unlock(&u_other->peer_wait.lock);
@@ -485,6 +485,7 @@ static void unix_sock_destructor(struct sock *sk)
 
 	if (u->addr)
 		unix_release_addr(u->addr);
+	unix_release_peer_wake(u);
 
 	atomic_long_dec(&unix_nr_socks);
 	local_bh_disable();
@@ -743,6 +744,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock)
 {
 	struct sock *sk = NULL;
 	struct unix_sock *u;
+	struct unix_peer_wake *pw;
+
+	pw = kmalloc(sizeof(*pw), GFP_KERNEL);
+	if (!pw)
+		return NULL;
 
 	atomic_long_inc(&unix_nr_socks);
 	if (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())
@@ -767,12 +773,14 @@ static struct sock *unix_create1(struct net *net, struct socket *sock)
 	INIT_LIST_HEAD(&u->link);
 	mutex_init(&u->readlock); /* single task reading lock */
 	init_waitqueue_head(&u->peer_wait);
-	init_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);
+	set_peer_wake(u, pw);
+	init_waitqueue_func_entry(get_peer_wake(u), unix_dgram_peer_wake_relay);
 	unix_insert_socket(unix_sockets_unbound(sk), sk);
 out:
-	if (sk == NULL)
+	if (sk == NULL) {
 		atomic_long_dec(&unix_nr_socks);
-	else {
+		kfree(pw);
+	} else {
 		local_bh_disable();
 		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);
 		local_bh_enable();
-- 
2.8.2

