From: Ganapatrao Kulkarni <gkulkarni@caviumnetworks.com>
Subject: [PATCH v2 RESEND] irqchip, gicv3-its,
 numa: Workaround for Cavium ThunderX erratum 23144
Date: Wed, 26 Aug 2015 10:22:39 +0530
Patch-mainline: Submitted, https://lkml.org/lkml/2015/8/26/13

This implements a workaround for gicv3-its erratum 23144 on Cavium's
ThunderX dual-socket platforms, where LPI cannot be routed to a
redistributors present on a foreign node.

Signed-off-by: Ganapatrao Kulkarni <gkulkarni@caviumnetworks.com>
Signed-off-by: Robert Richter <rrichter@cavium.com>
Signed-off-by: Matthias Brugger <mbrugger@suse.com>
---

The patch below is on top of Robert's recent gicv3 errata patch
submission v4 and my arm64 numa patches v5.

v2:
updatated as per Marc Zyngier's review comments.

 drivers/irqchip/irq-gic-v3-its.c |   49 +++++++++++++++++++++++++++++++++------
 1 file changed, 42 insertions(+), 7 deletions(-)

Index: current/drivers/irqchip/irq-gic-v3-its.c
===================================================================
--- current.orig/drivers/irqchip/irq-gic-v3-its.c
+++ current/drivers/irqchip/irq-gic-v3-its.c
@@ -42,6 +42,7 @@
 
 #define ITS_FLAGS_CMDQ_NEEDS_FLUSHING		(1ULL << 0)
 #define ITS_FLAGS_WORKAROUND_CAVIUM_22375	(1ULL << 1)
+#define ITS_WORKAROUND_CAVIUM_23144            (1ULL << 2)
 
 #define RDIST_FLAGS_PROPBASE_NEEDS_FLUSHING	(1 << 0)
 
@@ -74,6 +75,7 @@ struct its_node {
 	struct list_head	its_device_list;
 	u64			flags;
 	u32			ite_size;
+	int			numa_node;
 };
 
 #define ITS_ITT_ALIGN		SZ_256
@@ -608,11 +610,20 @@ static void its_eoi_irq(struct irq_data
 static int its_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 			    bool force)
 {
-	unsigned int cpu = cpumask_any_and(mask_val, cpu_online_mask);
+	unsigned int cpu;
+	const struct cpumask *cpu_mask = cpu_online_mask;
 	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
 	struct its_collection *target_col;
 	u32 id = its_get_event_id(d);
 
+	/* lpi cannot be routed to a redistributor that is on a foreign node */
+	if (its_dev->its->flags & ITS_WORKAROUND_CAVIUM_23144) {
+		cpu_mask = cpumask_of_node(its_dev->its->numa_node);
+		if (!cpumask_intersects(mask_val, cpu_mask))
+			return -EINVAL;
+	}
+
+	cpu = cpumask_any_and(mask_val, cpu_mask);
 	if (cpu >= nr_cpu_ids)
 		return -EINVAL;
 
@@ -1372,9 +1383,14 @@ static void its_irq_domain_activate(stru
 {
 	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
 	u32 event = its_get_event_id(d);
+	const struct cpumask *cpu_mask = cpu_online_mask;
+
+	/* get the cpu_mask of local node */
+	if (IS_ENABLED(CONFIG_NUMA))
+		cpu_mask = cpumask_of_node(its_dev->its->numa_node);
 
 	/* Bind the LPI to the first possible CPU */
-	its_dev->event_map.col_map[event] = cpumask_first(cpu_online_mask);
+	its_dev->event_map.col_map[event] = cpumask_first(cpu_mask);
 
 	/* Map the GIC IRQ and event to the device */
 	its_send_mapvi(its_dev, d->hwirq, event);
@@ -1464,6 +1480,14 @@ static void __maybe_unused its_enable_qu
 	its->flags |= ITS_FLAGS_WORKAROUND_CAVIUM_22375;
 }
 
+static void its_enable_cavium_thunderx_23144(void *data)
+{
+       struct its_node *its = data;
+
+       if (num_possible_nodes() > 1)
+               its->flags |= ITS_WORKAROUND_CAVIUM_23144;
+}
+
 static const struct gic_quirk its_quirks[] = {
 #ifdef CONFIG_CAVIUM_ERRATUM_22375
 	{
@@ -1472,6 +1496,12 @@ static const struct gic_quirk its_quirks
 		.mask	= 0xffff0fff,
 		.init	= its_enable_quirk_cavium_22375,
 	},
+       {
+               .desc   = "ITS: Cavium errata 23144",
+               .iidr   = 0xa100034c,   /* ThunderX pass 1.x */
+               .mask   = 0xffff0fff,
+               .init   = its_enable_cavium_thunderx_23144,
+       },
 #endif
 	{
 	}
@@ -1492,6 +1522,7 @@ static int its_probe(struct device_node
 	u32 val;
 	u64 baser, tmp;
 	int err;
+	int numa_node;
 
 	err = of_address_to_resource(node, 0, &res);
 	if (err) {
@@ -1499,6 +1530,9 @@ static int its_probe(struct device_node
 		return -ENXIO;
 	}
 
+	/* get numa affinity of its node*/
+	numa_node = of_node_to_nid(node);
+
 	its_base = ioremap(res.start, resource_size(&res));
 	if (!its_base) {
 		pr_warn("%s: unable to map registers\n", node->full_name);
@@ -1534,6 +1568,7 @@ static int its_probe(struct device_node
 	its->phys_base = res.start;
 	its->msi_chip.of_node = node;
 	its->ite_size = ((readl_relaxed(its_base + GITS_TYPER) >> 4) & 0xf) + 1;
+	its->numa_node = numa_node;
 
 	its->cmd_base = kzalloc(ITS_CMD_QUEUE_SZ, GFP_KERNEL);
 	if (!its->cmd_base) {
